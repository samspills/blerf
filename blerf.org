#+hugo_base_dir: ./
#+hugo_section: words

#+seq_todo: TODO DRAFT DONE

#+property: header-args :eval never-export
#+options: creator:t

#+STARTUP: indent
#+STARTUP: logdone

#+AUTHOR: Sam Pillsworth

* General
** DONE I blerfed it :nonsense:
CLOSED: [2023-01-23 Mon 23:23]
:PROPERTIES:
:EXPORT_FILE_NAME: blerfed-it
:END:
What's up nerds[fn:1], I'm back. Trying to figure this whole situation out.
To figure out:
- [X] is this post getting generated?
- [X] how to make a footnote?
- [X] What do these checkboxes look like?
  - they look totally reasonable
- [X] Did I figure out syntax highlighting?
  + hot damn I did! Good job Past Sam!
- [X] different code styling?
- [X] line numbers??

I am looking at this on a small screen and it looks not great. I think I would like to experiment
with different themes that are better layouts on a small screen.

#+begin_src scala
// this is just some sample code to check highlighting
def blerf(name: String): Unit = println(s"Hey, ${name}, did you know that Sam blerfed it?")
#+end_src

*** To remember in the future
- If the netlify preview build fails but everything works locally, check the hugo version
- not all chromastyles are available it seems?
- the leading slashes for the logo paths are important
* Emacs
** DRAFT Blerfs with ox-hugo
    This is a draft about writing using ox-hugo.
* Scala :scala:
** DRAFT Refs and Streams 1: Scheduling Updates :cats_effect:fs2:
:PROPERTIES:
:EXPORT_FILE_NAME: refs-and-streams-1
:END:
The past few weeks at ~$work~ I've been working on a fun little problem. We have some data on disk,
and we have an API that returns rows from this dataset. This is a prototype/first version and the
data is reasonably small (for now) so we can hold it in memory. But a different process will update
the data, and we need to be able to grab those updates while our API is still serving requests.

I decided to take this as an opportunity to build up my understanding of cats-effect ~Ref~. A ~Ref~
"provides safe concurrent access and modification of its content,"[fn:2] so it seemed a reasonable
opportunity to take advantage of it. I also wanted to use an fs2 Stream to handle the scheduling
task (mostly because I know the fs2 stream API reasonably well and I could see how to do it).

To start I minimized the problem down:
- I have a ~Ref~, in IO, with an integer value
- I want to print the value every second
- I want to add 1 to the value every 3 seconds

We can do this by defining two methods (one for printing and one for updating). Both methods take in
the ~Ref~ and return a metered stream that does it's task. The two streams are run concurrently (and
interrupted after 10 seconds).

The code[fn:3] looks like so:
#+begin_src scala
//> using lib "co.fs2::fs2-core:3.4.0"
//> using lib "org.typelevel::cats-effect:3.4.4"

import fs2.Stream
import cats.effect.IO
import cats.effect.IOApp
import scala.concurrent.duration._
import cats.effect.kernel.Ref

object Scheduled extends IOApp.Simple {
  val theRefThing: IO[Ref[IO, Int]] = Ref[IO].of(1)

  def scheduledUpdate(ref: Ref[IO, Int]): Stream[IO, Unit] = {
    val prog = ref
      .updateAndGet(int => int + 1)
      .flatMap(int => IO.println(s"updated the ref to $int"))
    Stream.repeatEval(prog).metered(3.seconds)
  }

  def printRefThing(ref: Ref[IO, Int]): Stream[IO, Unit] = {
    val prog = ref.get
      .flatMap(int => IO.println(s"the current ref value is ${int}"))
    Stream.repeatEval(prog).metered(1.second)
  }

  def run: IO[Unit] = theRefThing.flatMap(ref =>
    printRefThing(ref)
      .concurrently(scheduledUpdate(ref))
      .interruptAfter(10.seconds)
      .compile
      .drain
  )
}
#+end_src

Note that setting up the ~Ref~, via ~Ref[IO].of(1)~, returns an ~IO[Ref[IO, Int]]~. In my head, I
describe this to myself as "a program that will produce a ~Ref[IO, Int]~". In the moment (and in the
haze of the holidays[fn:4]) I struggled here. If I passed that initial ~IO~ around directly, then
both streams would create a ~Ref~ each time their respective programs run. Instead what I had to do
was create the ~Ref~ first at the very beginning and then pass that created ~Ref~ around:
~theRefThing.flatMap( ref => ... use it here ... )~
* Footnotes
[fn:4] I didn't touch a computer for three whole weeks and it was glorious. I think my brain must
have assumed I'd given up on tech and flushed my memory, because when I got back
to work I could barely ~println("Hello, world")~
[fn:3] This code sample is also available as a gist:
https://gist.github.com/samspills/b1a3434e1bac21ac9c62004df2f25306. You can run it directly using
~scala-cli~.
[fn:2] https://typelevel.org/cats-effect/docs/std/ref
[fn:1] It's me. My past self is nerds.
