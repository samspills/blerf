#+hugo_base_dir: ./
#+hugo_section: words

#+seq_todo: TODO DRAFT DONE

#+property: header-args :eval never-export
#+options: creator:t

#+STARTUP: indent
#+STARTUP: logdone

#+AUTHOR: Sam Pillsworth

* General
** DONE I blerfed it :nonsense:
CLOSED: [2023-01-23 Mon 23:23]
:PROPERTIES:
:EXPORT_FILE_NAME: blerfed-it
:END:
What's up nerds[fn:1], I'm back. Trying to figure this whole situation out.
To figure out:
- [X] is this post getting generated?
- [X] how to make a footnote?
- [X] What do these checkboxes look like?
  - they look totally reasonable
- [X] Did I figure out syntax highlighting?
  + hot damn I did! Good job Past Sam!
- [X] different code styling?
- [X] line numbers??

I am looking at this on a small screen and it looks not great. I think I would like to experiment
with different themes that are better layouts on a small screen.

#+begin_src scala
// this is just some sample code to check highlighting
def blerf(name: String): Unit = println(s"Hey, ${name}, did you know that Sam blerfed it?")
#+end_src

*** To remember in the future
- If the netlify preview build fails but everything works locally, check the hugo version
- not all chromastyles are available it seems?
- the leading slashes for the logo paths are important
* Emacs
** DRAFT Blerfs with ox-hugo
    This is a draft about writing using ox-hugo.
* Scala :scala:
** DONE Refs and Streams 1: Scheduling Updates :cats_effect:fs2:rough_thoughts:
CLOSED: [2023-02-01 Wed 20:09]
:PROPERTIES:
:EXPORT_FILE_NAME: refs-and-streams-1
:END:

The past month at ~$work~ I've been working on a fun little problem, and I decided to minimize
it down as a future example for myself. This is part one of two parts.

*** The Problem
We have some data, rows of recommendations. The data is stored on disk, and we want to write an API
that will return rows based on some query. The data, for now, is small enough that it can be read
into memory when we start the server. A different process will update the data on disk however, and
we need that update to propagate to the server without disrupting running requests. The update is
the piece I've been working on.
*** The Code
I took this as an opportunity to build my understanding of [[https://typelevel.org/cats-effect/docs/std/ref][Cats Effect ~Ref~]], since it "provides
safe concurrent access and modification of its content." I also wanted to use an
[[https://fs2.io/#/][fs2]] ~Stream~ to handle the scheduling task (mostly because I know the fs2
stream API reasonably well and I could see how to do it. I'm not sure if there is a better way to do
that piece.).

To start I defined a "simpler" version of my problem:
- suppose I have a single ~Ref~, in IO, with an integer value
- I want to print the value every second
- I want to add 1 to the value every 3 seconds

The implementation[fn:3] for this reduced problem looks like so:
#+begin_src scala
//> using lib "co.fs2::fs2-core:3.4.0"
//> using lib "org.typelevel::cats-effect:3.4.4"

import fs2.Stream
import cats.effect.IO
import cats.effect.IOApp
import scala.concurrent.duration._
import cats.effect.kernel.Ref

object Scheduled extends IOApp.Simple {
  val theRefThing: IO[Ref[IO, Int]] = Ref[IO].of(1)

  def scheduledUpdate(ref: Ref[IO, Int]): Stream[IO, Unit] = {
    val prog = ref
      .updateAndGet(int => int + 1)
      .flatMap(int => IO.println(s"updated the ref to $int"))
    Stream.repeatEval(prog).metered(3.seconds)
  }

  def printRefThing(ref: Ref[IO, Int]): Stream[IO, Unit] = {
    val prog = ref.get
      .flatMap(int => IO.println(s"the current ref value is ${int}"))
    Stream.repeatEval(prog).metered(1.second)
  }

  def run: IO[Unit] = theRefThing.flatMap(ref =>
    printRefThing(ref)
      .concurrently(scheduledUpdate(ref))
      .interruptAfter(10.seconds)
      .compile
      .drain
  )
}
#+end_src

The ~scheduledUpdate~ and ~printRefThing~ methods both take in the ref as an argument. The
scheduling (printing every 1 second, or updating every 3 seconds) is handled by metering the
streams.

The entire experiment is orchestrated together in the ~run~ method, by creating ~theRefThing~
*once*, and passing that same value to both methods. Those methods are run concurrently and
interrupted after 10 seconds.

I emphasize *once* because in the moment (and in the haze of the holidays[fn:4]) I struggled here.
If I passed that initial ~IO~ around directly, then both streams would create a ~Ref~ each time
their respective programs ran. Both methods needs to be using the same ~Ref~ for any of this to
work.

The next step, which I'll write up separately, expands this reduced problem to include the API piece
(using [[https://http4s.org/][Http4s]]).
* Footnotes
[fn:4] I didn't touch a computer for three whole weeks and it was glorious. I think my brain must
have assumed I'd given up on tech and flushed my memory, because when I got back
to work I could barely ~println("Hello, world")~
[fn:3] This code sample is also available as [[https://gist.github.com/samspills/b1a3434e1bac21ac9c62004df2f25306][a gist]]. You can run it directly using [[https://scala-cli.virtuslab.org/][scala-cli]].
[fn:1] It's me. My past self is nerds.
